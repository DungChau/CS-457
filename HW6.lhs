-------------------------------------------------------------

CS457/557 Functional Languages, Winter 2012 

Homework 6

Dung Chau

-------------------------------------------------------------

> import Treedot

> import Data.Maybe

-------------------------------------------------------------

1) First, define a tree-like type, VizTree, for capturing the structure of data values. Something like the following would be a good choice: it would allow you to specify a String label for every node in the tree, and it would also allow each tree node to have zero or more subtrees:

> data VizTree = VizNode String [ VizTree ]

Of course, if you’re going to use this type with the Treedot library, then there are a couple of other things we’re going to have to define. What might they be, for instance?

First of all, we can declare an instance of type class Tree as VizTree with subtrees accepts a leaf node and return empty list or accepts a node that has one or more child nodes.  

> instance Tree VizTree where
>	subtrees (VizNode x []) = []
>	subtrees (VizNode x xs) = xs  

Then we have to define an instance of LabeledTree which has label accepts a node which has a list of child nodes or empty list of childs and return the string label.

> instance LabeledTree VizTree where
>	label (VizNode x ys) = x 

2) Second, define a type class of visualizable types, meaning types whose values can be converted into appropriate trees of type VizTree. As you quickly realize, there’s a classy way to do this:

> class Viz a where
>   toVizTree 	:: a -> VizTree
>   toVizList   :: [a] -> VizTree
>   toVizList   [] = VizNode "[]" []
>   toVizList (x:xs) = VizNode ":" [toVizTree x, toVizTree xs]

> instance Viz Integer where
>   toVizTree n = VizNode (show n) []

> instance Viz Char where
>   toVizTree n = VizNode (show n) []
>   toVizList s = VizNode ("\\\""++s++"\\\"") []

> instance Viz a => Viz [a] where
>   toVizTree = toVizList

   toVizTree []     = VizNode "[]" []
   toVizTree (x:xs) = VizNode ":"  [toVizTree x, toVizTree xs]
   

In the last line of the block of code above, we have have toVizTree x and toVizTree xs in the same list. This is absolutly possible, since we define it as a list of some type a. For instance, xs is a list, it can be written as [x1,x2,x3,x4] or it can be written as x1:x2:x3:x4:[], so when toVizTree apply to the list it will recurively apply to all element in the list.
Thus x or xs can be applied to toVizTree.

Write out some more instance declarations that would add, say, Bool, Int, pairs, triples, and Maybe types to the Viz class:

> instance Viz Bool where
>	toVizTree True = VizNode "True" []
>	toVizTree False = VizNode "False" []

> instance Viz Int where
>	toVizTree n = VizNode (show n) []

> instance (Viz a, Viz b) => Viz ((a,b)) where
>	toVizTree ((a,b)) = VizNode "pair" [toVizTree a, toVizTree b]  

> instance (Viz a, Viz b, Viz c) => Viz ((a,b,c)) where
>	toVizTree ((a,b,c)) = VizNode "triple" [toVizTree a, toVizTree b, toVizTree c]

> instance (Viz a) => Viz (Maybe a) where
>	toVizTree Nothing = VizNode "Nothing" []
>	toVizTree (Just a) = VizNode "Just" [toVizTree a]

Then the proffesor defines ssomething to produce a tree.dot file in order to display the tree using Graphviz:

> viz :: Viz a => a -> IO ()
> viz  = writeFile "tree.dot" . toDot . toVizTree

One unfortunate detail here: Prof. Senoj wishes that he didn’t have to include that type annotation, ::Integer, in the examples above. But things don’t work correctly when he leaves it out; can you explain why it is necessary in these cases?

if we don't specify the type by using type annotation the it won't know which instance to use to turn a piece of data to VizTree. There are some example provided by the professor:
	HW6> :t viz [1..4]
	viz (enumFromTo 1 4) :: (Viz a, Num a, Enum a) => IO ()
we can see that it has different types in the report generated by Hugs.

When he tries to do:

viz "Thanks!"

then what he got is a huge tree instead of a node labeled "Thanks". We add to above definitions:

+ Three extra lines to the definition of the Viz class
+ An extra line to the instance of Viz for the Char type
And:
+ Replace the instance declaration for Viz on lists :
     instance Viz a => Viz [a] where
  	toVizTree = toVizList

